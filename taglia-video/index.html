<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Taglia Video - CronoTools 3.2</title>
    <link rel="stylesheet" href="../css/style.css">
    
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.10.1/dist/ffmpeg.min.js"></script>

    <style>
        .video-wrapper { width: 100%; background: #000; border-radius: 12px; overflow: hidden; margin-bottom: 20px; position: relative; }
        video { width: 100%; display: block; max-height: 50vh; }
        .timeline-controls { padding: 20px; }
        .time-display { display: flex; justify-content: space-between; font-family: monospace; font-size: 14px; margin-bottom: 10px; font-weight: 600; color: var(--accent); }
        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; }
        
        /* Overlay Loading */
        .processing-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 9999;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        .processing-overlay.active { display: flex; }
        .spinner {
            width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-radius: 50%;
            border-top-color: var(--accent); animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        .processing-text { color: white; font-weight: 600; font-size: 18px; }
        .processing-sub { color: rgba(255,255,255,0.7); font-size: 14px; margin-top: 5px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <crono-navbar></crono-navbar>
    
    <div id="processing-overlay" class="processing-overlay">
        <div class="spinner"></div>
        <div class="processing-text" id="proc-text">Inizializzazione Motore Video...</div>
        <div class="processing-sub">Potrebbe richiedere un minuto al primo avvio.</div>
    </div>

    <div class="content-wrapper">
        <header class="main-header">
            <h1>Taglia Video</h1>
            <p class="description">Taglio reale senza re-coding (Stream Copy). Veloce e lossless.</p>
        </header>
        <main>
            <div id="upload-stage" class="upload-area">
                <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>
                <div class="upload-title">Carica Video</div>
                <div class="upload-desc">MP4, MOV, WEBM (Max 2GB consigliato)</div>
                <input type="file" id="file-input" accept="video/*" hidden>
            </div>

            <div id="workspace-stage" class="workspace-container">
                <div class="glass-card">
                    <div class="video-wrapper">
                        <video id="video-preview" controls playsinline></video>
                    </div>
                    <div class="timeline-controls">
                        <div class="time-display">
                            <span>Inizio: <span id="val-start">0.0s</span></span>
                            <span>Durata Clip: <span id="val-dur" style="color:var(--text-primary)">0.0s</span></span>
                            <span>Fine: <span id="val-end">0.0s</span></span>
                        </div>
                        
                        <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Punto Inizio</p>
                        <input type="range" id="range-start" value="0" step="0.1">
                        
                        <p style="font-size: 12px; color: var(--text-secondary); margin: 12px 0 8px;">Punto Fine</p>
                        <input type="range" id="range-end" value="100" step="0.1">
                    </div>
                    
                    <div style="padding: 20px; text-align: center;">
                        <button id="btn-process" class="alert-btn primary">Taglia e Scarica</button>
                        <button class="btn" onclick="location.reload()" style="margin-top:10px; background: transparent; color: var(--danger); border:none; cursor:pointer;">Annulla / Nuovo</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script src="../js/ui.js"></script>
    <script src="../components/navbar.js"></script>
    
    <script>
        const { createFFmpeg, fetchFile } = FFmpeg;
        
        // Configurazione FFmpeg
        // Usiamo log: true per debug e corePath automatico da CDN unpkg
        const ffmpeg = createFFmpeg({ log: true });

        const video = document.getElementById('video-preview');
        const rangeStart = document.getElementById('range-start');
        const rangeEnd = document.getElementById('range-end');
        const overlay = document.getElementById('processing-overlay');
        const procText = document.getElementById('proc-text');
        
        let originalFile = null;
        let isEngineReady = false;

        // --- INIT ENGINE ---
        // Carichiamo FFmpeg appena possibile in background
        (async () => {
            try {
                if (!ffmpeg.isLoaded()) {
                    await ffmpeg.load();
                    isEngineReady = true;
                    console.log("FFmpeg Ready");
                }
            } catch (e) {
                console.error("FFmpeg load failed", e);
                // Fallback o avviso se il browser è troppo vecchio
            }
        })();

        // --- UPLOAD HANDLER ---
        document.getElementById('upload-stage').addEventListener('click', () => document.getElementById('file-input').click());
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                originalFile = file;
                const url = URL.createObjectURL(file);
                video.src = url;
                document.getElementById('upload-stage').style.display = 'none';
                document.getElementById('workspace-stage').style.display = 'block';
            }
        });

        // --- TIMELINE LOGIC ---
        video.addEventListener('loadedmetadata', () => {
            const duration = video.duration;
            rangeStart.max = duration;
            rangeEnd.max = duration;
            rangeEnd.value = duration;
            rangeStart.value = 0;
            updateLabels();
        });

        rangeStart.addEventListener('input', () => {
            if(parseFloat(rangeStart.value) >= parseFloat(rangeEnd.value)) {
                rangeStart.value = parseFloat(rangeEnd.value) - 0.5;
            }
            video.currentTime = rangeStart.value;
            updateLabels();
        });

        rangeEnd.addEventListener('input', () => {
            if(parseFloat(rangeEnd.value) <= parseFloat(rangeStart.value)) {
                rangeEnd.value = parseFloat(rangeStart.value) + 0.5;
            }
            video.currentTime = rangeEnd.value;
            updateLabels();
        });

        function updateLabels() {
            const s = parseFloat(rangeStart.value);
            const e = parseFloat(rangeEnd.value);
            document.getElementById('val-start').textContent = s.toFixed(1) + 's';
            document.getElementById('val-end').textContent = e.toFixed(1) + 's';
            document.getElementById('val-dur').textContent = (e - s).toFixed(1) + 's';
        }

        // --- PROCESSING LOGIC (THE REAL DEAL) ---
        document.getElementById('btn-process').addEventListener('click', async () => {
            if (!originalFile) return;

            // Mostra overlay
            overlay.classList.add('active');

            try {
                // 1. Check motore
                if (!ffmpeg.isLoaded()) {
                    procText.textContent = "Caricamento Core FFmpeg (25MB)...";
                    await ffmpeg.load();
                }

                // 2. Scrittura File in Memoria
                procText.textContent = "Lettura file in memoria...";
                const inputName = 'input_video';
                const outputName = 'output_video.mp4';
                
                // FetchFile converte il File object in Uint8Array per FFmpeg
                ffmpeg.FS('writeFile', inputName, await fetchFile(originalFile));

                // 3. Esecuzione Comando
                // -ss: Start time
                // -t: Duration (End - Start)
                // -c copy: STREAM COPY (Taglio istantaneo senza ricodifica, conserva qualità originale)
                // Nota: -c copy taglia al keyframe più vicino. È veloce. 
                // Se si vuole precisione al millisecondo servirebbe ricodifica (-c:v libx264), ma è lento in JS.
                
                const startTime = rangeStart.value;
                const duration = (rangeEnd.value - rangeStart.value).toFixed(2);
                
                procText.textContent = "Elaborazione taglio...";
                
                // Eseguiamo FFmpeg
                await ffmpeg.run(
                    '-ss', startTime,
                    '-i', inputName,
                    '-t', duration,
                    '-c', 'copy', // Super veloce, niente perdita qualità
                    outputName
                );

                // 4. Lettura Output
                procText.textContent = "Generazione file finale...";
                const data = ffmpeg.FS('readFile', outputName);

                // 5. Creazione Link Download
                const url = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
                const a = document.createElement('a');
                a.href = url;
                a.download = `crono-cut-${Date.now()}.mp4`;
                a.click();

                // Pulizia Memoria (Importante per non crashare il browser)
                try {
                    ffmpeg.FS('unlink', inputName);
                    ffmpeg.FS('unlink', outputName);
                } catch(e) {}

                // Chiudi overlay
                setTimeout(() => {
                    overlay.classList.remove('active');
                    procText.textContent = "Pronto";
                }, 1000);

            } catch (err) {
                console.error(err);
                alert("Errore durante l'elaborazione. Il video potrebbe essere corrotto o il browser non supporta WebAssembly/SharedArrayBuffer.");
                overlay.classList.remove('active');
            }
        });
    </script>
</body>
</html>